import {
  MaintenanceType,
  Prisma,
  TruckMaintenanceState,
  WorkOrderStatus
} from "@prisma/client";
import { formatWorkorderNumber, temporaryWorkorderNumber } from "@/lib/workorder";

export type MaintenanceHealth = "OK" | "DUE_SOON" | "DUE" | "OVERDUE";

export type MaintenanceSnapshotItem = {
  maintenanceTypeId: string;
  maintenanceName: string;
  intervalMiles: number;
  warningBeforeMiles: number;
  lastServiceOdometer: number;
  milesSinceLastService: number;
  remainingMiles: number;
  health: MaintenanceHealth;
  overdueMiles: number;
  openWorkOrderId?: string;
  openWorkOrderNumber?: string;
};

function classifyHealth(
  milesSinceLastService: number,
  intervalMiles: number,
  warningBeforeMiles: number
): MaintenanceHealth {
  if (milesSinceLastService > intervalMiles) return "OVERDUE";
  if (milesSinceLastService === intervalMiles) return "DUE";

  const remaining = intervalMiles - milesSinceLastService;
  if (remaining <= warningBeforeMiles) return "DUE_SOON";

  return "OK";
}

async function ensureMaintenanceState(
  tx: Prisma.TransactionClient,
  truckId: string,
  maintenanceTypeId: string
): Promise<TruckMaintenanceState> {
  return tx.truckMaintenanceState.upsert({
    where: {
      truckId_maintenanceTypeId: {
        truckId,
        maintenanceTypeId
      }
    },
    update: {},
    create: {
      truckId,
      maintenanceTypeId,
      lastServiceOdometer: 0
    }
  });
}

async function createOrGetOpenWorkOrder(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
  maintenanceType: MaintenanceType;
  dueAtOdometer: number;
  createdFromEntryId?: string;
}): Promise<string> {
  const { tx, truckId, maintenanceType, dueAtOdometer, createdFromEntryId } = params;

  const openOrder = await tx.workOrder.findFirst({
    where: {
      truckId,
      maintenanceTypeId: maintenanceType.id,
      status: {
        in: [WorkOrderStatus.PENDING, WorkOrderStatus.IN_PROGRESS]
      }
    }
  });

  if (openOrder) {
    return openOrder.id;
  }

  const created = await tx.workOrder.create({
    data: {
      workorderNumber: temporaryWorkorderNumber(),
      truckId,
      maintenanceTypeId: maintenanceType.id,
      status: WorkOrderStatus.PENDING,
      dueAtOdometer,
      createdFromEntryId,
      autoGenerated: true
    }
  });

  const finalized = await tx.workOrder.update({
    where: { id: created.id },
    data: {
      workorderNumber: formatWorkorderNumber(created.serialNumber)
    }
  });

  return finalized.id;
}

async function cancelNoLongerDuePendingOrders(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
  maintenanceTypeId: string;
}) {
  const { tx, truckId, maintenanceTypeId } = params;

  await tx.workOrder.updateMany({
    where: {
      truckId,
      maintenanceTypeId,
      autoGenerated: true,
      status: WorkOrderStatus.PENDING
    },
    data: {
      status: WorkOrderStatus.CANCELLED,
      completedAt: new Date()
    }
  });
}

export async function evaluateTruckMaintenance(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
  currentOdometer: number;
  createdFromEntryId?: string;
  pruneNotDue?: boolean;
}): Promise<MaintenanceSnapshotItem[]> {
  const { tx, truckId, currentOdometer, createdFromEntryId, pruneNotDue = false } = params;

  const maintenanceTypes = await tx.maintenanceType.findMany({
    where: { isActive: true },
    orderBy: { intervalMiles: "asc" }
  });

  const snapshots: MaintenanceSnapshotItem[] = [];

  for (const mt of maintenanceTypes) {
    const state = await ensureMaintenanceState(tx, truckId, mt.id);

    const milesSince = currentOdometer - state.lastServiceOdometer;
    const remaining = mt.intervalMiles - milesSince;
    const health = classifyHealth(milesSince, mt.intervalMiles, mt.warningBeforeMiles);
    const overdueMiles = Math.max(0, milesSince - mt.intervalMiles);

    let openOrderId: string | undefined;
    let openOrderNumber: string | undefined;

    if (milesSince >= mt.intervalMiles) {
      openOrderId = await createOrGetOpenWorkOrder({
        tx,
        truckId,
        maintenanceType: mt,
        dueAtOdometer: state.lastServiceOdometer + mt.intervalMiles,
        createdFromEntryId
      });

      const wo = await tx.workOrder.findUnique({ where: { id: openOrderId } });
      openOrderNumber = wo?.workorderNumber;
    } else if (pruneNotDue) {
      await cancelNoLongerDuePendingOrders({ tx, truckId, maintenanceTypeId: mt.id });
    }

    snapshots.push({
      maintenanceTypeId: mt.id,
      maintenanceName: mt.name,
      intervalMiles: mt.intervalMiles,
      warningBeforeMiles: mt.warningBeforeMiles,
      lastServiceOdometer: state.lastServiceOdometer,
      milesSinceLastService: milesSince,
      remainingMiles: remaining,
      health,
      overdueMiles,
      openWorkOrderId: openOrderId,
      openWorkOrderNumber: openOrderNumber
    });
  }

  return snapshots;
}

export async function recomputeYardEntriesAndTruckOdometer(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
}): Promise<number> {
  const { tx, truckId } = params;

  const entries = await tx.yardEntry.findMany({
    where: { truckId },
    orderBy: [{ datetime: "asc" }, { createdAt: "asc" }]
  });

  let previous = 0;

  for (const [index, entry] of entries.entries()) {
    const delta = index === 0 ? entry.odometer : entry.odometer - previous;
    previous = entry.odometer;

    if (entry.computedDelta !== delta) {
      await tx.yardEntry.update({
        where: { id: entry.id },
        data: { computedDelta: delta }
      });
    }
  }

  const latest = entries.at(-1);
  const currentOdometer = latest?.odometer ?? 0;

  await tx.truck.update({
    where: { id: truckId },
    data: { currentOdometer }
  });

  return currentOdometer;
}

export async function refreshMaintenanceStatesFromHistory(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
}) {
  const { tx, truckId } = params;
  const maintenanceTypes = await tx.maintenanceType.findMany({ where: { isActive: true } });

  for (const mt of maintenanceTypes) {
    const latestService = await tx.serviceHistory.findFirst({
      where: {
        truckId,
        maintenanceTypeId: mt.id
      },
      orderBy: { performedAt: "desc" }
    });

    await tx.truckMaintenanceState.upsert({
      where: {
        truckId_maintenanceTypeId: {
          truckId,
          maintenanceTypeId: mt.id
        }
      },
      update: {
        lastServiceOdometer: latestService?.odometerAtService ?? 0,
        lastServiceAt: latestService?.performedAt ?? null
      },
      create: {
        truckId,
        maintenanceTypeId: mt.id,
        lastServiceOdometer: latestService?.odometerAtService ?? 0,
        lastServiceAt: latestService?.performedAt ?? null
      }
    });
  }
}

export async function recalculateTruckImpact(params: {
  tx: Prisma.TransactionClient;
  truckId: string;
}) {
  const { tx, truckId } = params;

  const currentOdometer = await recomputeYardEntriesAndTruckOdometer({ tx, truckId });
  await refreshMaintenanceStatesFromHistory({ tx, truckId });
  await evaluateTruckMaintenance({
    tx,
    truckId,
    currentOdometer,
    pruneNotDue: true
  });
}
