import {
  HealthState,
  LocalDbState,
  MaintenanceType,
  ServiceHistory,
  Truck,
  TruckMaintenanceState,
  WorkOrder,
  WorkOrderStatus
} from "@/types/local-domain";
import { loadDbState, newId, nowIso, resetDbState, saveDbState, withDbState } from "@/lib/local/store";

type MaintenanceSnapshotItem = {
  maintenanceTypeId: string;
  maintenanceName: string;
  intervalMiles: number;
  warningBeforeMiles: number;
  lastServiceOdometer: number;
  milesSinceLastService: number;
  remainingMiles: number;
  health: HealthState;
  overdueMiles: number;
  openWorkOrderId?: string;
  openWorkOrderNumber?: string;
};

type ReportQuery = {
  period?: "week" | "month" | "custom";
  from?: string;
  to?: string;
  truckId?: string;
};

function sortByDateAsc<T extends { datetime: string; createdAt: string }>(rows: T[]) {
  return [...rows].sort((a, b) => {
    const byDate = new Date(a.datetime).getTime() - new Date(b.datetime).getTime();
    if (byDate !== 0) return byDate;
    return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
  });
}

function sortByDateDesc<T extends { datetime: string; createdAt: string }>(rows: T[]) {
  return sortByDateAsc(rows).reverse();
}

function getActorFromState(state: LocalDbState) {
  return (
    state.users.find((user) => user.id === state.currentActorId) ??
    state.users.find((user) => user.role === "OPERATOR") ??
    state.users[0]
  );
}

function getMaintenanceType(state: LocalDbState, maintenanceTypeId: string) {
  const type = state.maintenanceTypes.find((item) => item.id === maintenanceTypeId);
  if (!type) throw new Error("Tipo de mantenimiento no encontrado");
  return type;
}

function ensureMaintenanceState(
  state: LocalDbState,
  truckId: string,
  maintenanceTypeId: string
): TruckMaintenanceState {
  const existing = state.truckMaintenanceStates.find(
    (item) => item.truckId === truckId && item.maintenanceTypeId === maintenanceTypeId
  );

  if (existing) return existing;

  const createdAt = nowIso();
  const created: TruckMaintenanceState = {
    id: newId(),
    truckId,
    maintenanceTypeId,
    lastServiceOdometer: 0,
    createdAt,
    updatedAt: createdAt
  };

  state.truckMaintenanceStates.push(created);
  return created;
}

function classifyHealth(
  milesSinceLastService: number,
  intervalMiles: number,
  warningBeforeMiles: number
): HealthState {
  if (milesSinceLastService > intervalMiles) return "OVERDUE";
  if (milesSinceLastService === intervalMiles) return "DUE";

  const remaining = intervalMiles - milesSinceLastService;
  if (remaining <= warningBeforeMiles) return "DUE_SOON";
  return "OK";
}

function formatWorkOrderNumber(serialNumber: number) {
  return `OS-${serialNumber.toString().padStart(6, "0")}`;
}

function ensureOpenWorkOrder(params: {
  state: LocalDbState;
  truckId: string;
  maintenanceType: MaintenanceType;
  dueAtOdometer: number;
  createdFromEntryId?: string;
}): WorkOrder {
  const { state, truckId, maintenanceType, dueAtOdometer, createdFromEntryId } = params;

  const existing = state.workOrders.find(
    (item) =>
      item.truckId === truckId &&
      item.maintenanceTypeId === maintenanceType.id &&
      (item.status === "PENDING" || item.status === "IN_PROGRESS")
  );

  if (existing) return existing;

  state.meta.workOrderSerial += 1;
  const serialNumber = state.meta.workOrderSerial;
  const createdAt = nowIso();

  const created: WorkOrder = {
    id: newId(),
    serialNumber,
    workorderNumber: formatWorkOrderNumber(serialNumber),
    truckId,
    maintenanceTypeId: maintenanceType.id,
    status: "PENDING",
    createdAt,
    dueAtOdometer,
    createdFromEntryId,
    autoGenerated: true
  };

  state.workOrders.push(created);
  return created;
}

function cancelNoLongerDuePendingOrders(state: LocalDbState, truckId: string, maintenanceTypeId: string) {
  const completedAt = nowIso();
  for (const order of state.workOrders) {
    if (
      order.truckId === truckId &&
      order.maintenanceTypeId === maintenanceTypeId &&
      order.autoGenerated &&
      order.status === "PENDING"
    ) {
      order.status = "CANCELLED";
      order.completedAt = completedAt;
    }
  }
}

function evaluateTruckMaintenance(params: {
  state: LocalDbState;
  truckId: string;
  currentOdometer: number;
  createdFromEntryId?: string;
  pruneNotDue?: boolean;
}): MaintenanceSnapshotItem[] {
  const { state, truckId, currentOdometer, createdFromEntryId, pruneNotDue = false } = params;

  const activeTypes = state.maintenanceTypes
    .filter((item) => item.isActive)
    .sort((a, b) => a.intervalMiles - b.intervalMiles);

  const snapshots: MaintenanceSnapshotItem[] = [];

  for (const maintenanceType of activeTypes) {
    const stateRow = ensureMaintenanceState(state, truckId, maintenanceType.id);

    const milesSinceLastService = currentOdometer - stateRow.lastServiceOdometer;
    const remainingMiles = maintenanceType.intervalMiles - milesSinceLastService;
    const health = classifyHealth(
      milesSinceLastService,
      maintenanceType.intervalMiles,
      maintenanceType.warningBeforeMiles
    );

    const overdueMiles = Math.max(0, milesSinceLastService - maintenanceType.intervalMiles);
    let openWorkOrder: WorkOrder | undefined;

    if (milesSinceLastService >= maintenanceType.intervalMiles) {
      openWorkOrder = ensureOpenWorkOrder({
        state,
        truckId,
        maintenanceType,
        dueAtOdometer: stateRow.lastServiceOdometer + maintenanceType.intervalMiles,
        createdFromEntryId
      });
    } else if (pruneNotDue) {
      cancelNoLongerDuePendingOrders(state, truckId, maintenanceType.id);
    }

    snapshots.push({
      maintenanceTypeId: maintenanceType.id,
      maintenanceName: maintenanceType.name,
      intervalMiles: maintenanceType.intervalMiles,
      warningBeforeMiles: maintenanceType.warningBeforeMiles,
      lastServiceOdometer: stateRow.lastServiceOdometer,
      milesSinceLastService,
      remainingMiles,
      health,
      overdueMiles,
      openWorkOrderId: openWorkOrder?.id,
      openWorkOrderNumber: openWorkOrder?.workorderNumber
    });
  }

  return snapshots;
}

function recomputeYardEntriesAndTruckOdometer(state: LocalDbState, truckId: string): number {
  const entries = sortByDateAsc(state.yardEntries.filter((entry) => entry.truckId === truckId));

  let previous = 0;
  for (const [index, entry] of entries.entries()) {
    const expectedDelta = index === 0 ? entry.odometer : entry.odometer - previous;
    previous = entry.odometer;

    if (entry.computedDelta !== expectedDelta) {
      entry.computedDelta = expectedDelta;
      entry.updatedAt = nowIso();
    }
  }

  const latest = entries.at(-1);
  const currentOdometer = latest?.odometer ?? 0;
  const truck = state.trucks.find((item) => item.id === truckId);

  if (truck) {
    truck.currentOdometer = currentOdometer;
    truck.updatedAt = nowIso();
  }

  return currentOdometer;
}

function refreshMaintenanceStatesFromHistory(state: LocalDbState, truckId: string) {
  const activeTypes = state.maintenanceTypes.filter((item) => item.isActive);

  for (const maintenanceType of activeTypes) {
    const latestService = [...state.serviceHistory]
      .filter(
        (item) => item.truckId === truckId && item.maintenanceTypeId === maintenanceType.id
      )
      .sort((a, b) => new Date(b.performedAt).getTime() - new Date(a.performedAt).getTime())[0];

    const row = ensureMaintenanceState(state, truckId, maintenanceType.id);
    row.lastServiceOdometer = latestService?.odometerAtService ?? 0;
    row.lastServiceAt = latestService?.performedAt;
    row.updatedAt = nowIso();
  }
}

function recalculateTruckImpact(state: LocalDbState, truckId: string) {
  const currentOdometer = recomputeYardEntriesAndTruckOdometer(state, truckId);
  refreshMaintenanceStatesFromHistory(state, truckId);
  evaluateTruckMaintenance({
    state,
    truckId,
    currentOdometer,
    pruneNotDue: true
  });
}

function parseDateRange(query: ReportQuery) {
  const now = new Date();
  const period = query.period ?? "week";

  if (period === "month") {
    const start = new Date(now);
    start.setDate(now.getDate() - 30);
    return { start, end: now };
  }

  if (period === "custom") {
    if (!query.from || !query.to) {
      throw new Error("Para periodo custom debe enviar from y to");
    }

    const start = new Date(query.from);
    const end = new Date(query.to);

    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
      throw new Error("Rango custom inválido");
    }

    return { start, end };
  }

  const start = new Date(now);
  start.setDate(now.getDate() - 7);
  return { start, end: now };
}

function mapTruckMaintenanceState(state: LocalDbState, truck: Truck) {
  return state.truckMaintenanceStates
    .filter((row) => row.truckId === truck.id)
    .map((row) => ({
      ...row,
      maintenanceType: getMaintenanceType(state, row.maintenanceTypeId)
    }))
    .sort((a, b) => a.maintenanceType.intervalMiles - b.maintenanceType.intervalMiles);
}

function getServiceRowsByRange(state: LocalDbState, query: ReportQuery) {
  const { start, end } = parseDateRange(query);

  const rows = state.serviceHistory
    .filter((row) => {
      const date = new Date(row.performedAt).getTime();
      const inRange = date >= start.getTime() && date <= end.getTime();
      if (!inRange) return false;
      if (query.truckId && row.truckId !== query.truckId) return false;
      return true;
    })
    .sort((a, b) => new Date(b.performedAt).getTime() - new Date(a.performedAt).getTime());

  return { start, end, rows };
}

function asCsvCell(value: string | number | Date) {
  const raw = value instanceof Date ? value.toISOString() : String(value);
  return `"${raw.replaceAll('"', '""')}"`;
}

export const localService = {
  initialize() {
    const state = loadDbState();
    saveDbState(state);
    return state;
  },

  reset() {
    resetDbState();
  },

  getUsers() {
    const state = loadDbState();
    return state.users;
  },

  getCurrentActor() {
    const state = loadDbState();
    return getActorFromState(state);
  },

  setCurrentActor(actorId: string) {
    return withDbState((state) => {
      const actor = state.users.find((item) => item.id === actorId);
      if (!actor) throw new Error("Usuario no encontrado");
      state.currentActorId = actorId;
      return actor;
    });
  },

  getTrucks() {
    const state = loadDbState();
    return [...state.trucks]
      .sort((a, b) => a.truckNumber.localeCompare(b.truckNumber))
      .map((truck) => ({
        ...truck,
        maintenanceStates: mapTruckMaintenanceState(state, truck)
      }));
  },

  getTruckById(truckId: string) {
    const state = loadDbState();
    const truck = state.trucks.find((item) => item.id === truckId);
    if (!truck) throw new Error("Camión no encontrado");

    const yardEntries = sortByDateDesc(state.yardEntries.filter((entry) => entry.truckId === truck.id))
      .slice(0, 20)
      .map((entry) => ({
        ...entry,
        recordedBy: state.users.find((user) => user.id === entry.recordedById)
      }));

    const workOrders = [...state.workOrders]
      .filter((order) => order.truckId === truck.id)
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .slice(0, 20)
      .map((order) => ({
        ...order,
        maintenanceType: getMaintenanceType(state, order.maintenanceTypeId)
      }));

    return {
      ...truck,
      yardEntries,
      maintenanceStates: mapTruckMaintenanceState(state, truck),
      workOrders
    };
  },

  registerYardEntry(input: {
    truckId: string;
    odometer: number;
    notes?: string;
    photoUrl?: string;
    datetime?: string;
  }) {
    return withDbState((state) => {
      const actor = getActorFromState(state);
      const truck = state.trucks.find((item) => item.id === input.truckId);
      if (!truck) throw new Error("Camión no encontrado");

      const lastEntry = sortByDateDesc(
        state.yardEntries.filter((entry) => entry.truckId === truck.id)
      )[0];

      const previousOdometer = lastEntry?.odometer ?? 0;
      if (input.odometer < previousOdometer) {
        throw new Error(
          `Lectura inválida. El último odómetro es ${previousOdometer} y no puede disminuir.`
        );
      }

      const currentTime = nowIso();
      const computedDelta = input.odometer - previousOdometer;

      const entry = {
        id: newId(),
        truckId: truck.id,
        datetime: input.datetime ?? currentTime,
        odometer: input.odometer,
        computedDelta,
        recordedById: actor.id,
        notes: input.notes,
        photoUrl: input.photoUrl,
        createdAt: currentTime,
        updatedAt: currentTime
      };

      state.yardEntries.push(entry);
      truck.currentOdometer = input.odometer;
      truck.updatedAt = nowIso();

      const maintenanceSnapshot = evaluateTruckMaintenance({
        state,
        truckId: truck.id,
        currentOdometer: input.odometer,
        createdFromEntryId: entry.id
      });

      return {
        yardEntry: entry,
        maintenanceSnapshot,
        generatedWorkOrders: maintenanceSnapshot
          .filter((item) => !!item.openWorkOrderId)
          .map((item) => ({
            maintenanceName: item.maintenanceName,
            workOrderId: item.openWorkOrderId,
            workOrderNumber: item.openWorkOrderNumber,
            health: item.health
          }))
      };
    });
  },

  correctYardEntry(input: { entryId: string; odometer: number; reason: string }) {
    return withDbState((state) => {
      const actor = getActorFromState(state);
      if (actor.role !== "ADMIN") {
        throw new Error("Operación permitida solo para Admin");
      }

      if (!input.reason || input.reason.trim().length < 8) {
        throw new Error("Motivo obligatorio (mínimo 8 caracteres)");
      }

      const target = state.yardEntries.find((entry) => entry.id === input.entryId);
      if (!target) throw new Error("Entrada de yarda no encontrada");

      const ordered = sortByDateAsc(state.yardEntries.filter((entry) => entry.truckId === target.truckId));
      const index = ordered.findIndex((entry) => entry.id === target.id);
      if (index < 0) throw new Error("No se pudo ubicar la lectura a corregir");

      const previous = ordered[index - 1];
      const next = ordered[index + 1];

      if (previous && input.odometer < previous.odometer) {
        throw new Error(
          `Corrección inválida: el odómetro no puede ser menor al anterior (${previous.odometer})`
        );
      }

      if (next && input.odometer > next.odometer) {
        throw new Error(
          `Corrección inválida: el odómetro no puede ser mayor al siguiente (${next.odometer})`
        );
      }

      const oldOdometer = target.odometer;
      target.odometer = input.odometer;
      target.updatedAt = nowIso();

      state.auditLogs.push({
        id: newId(),
        entityType: "YardEntry",
        entityId: target.id,
        oldValue: { odometer: oldOdometer },
        newValue: { odometer: input.odometer },
        changedById: actor.id,
        reason: input.reason,
        timestamp: nowIso()
      });

      recalculateTruckImpact(state, target.truckId);

      return target;
    });
  },

  getWorkOrders(filters?: { truckId?: string; status?: WorkOrderStatus | "ALL" }) {
    const state = loadDbState();

    const rows = state.workOrders
      .filter((order) => {
        if (filters?.truckId && order.truckId !== filters.truckId) return false;
        if (filters?.status && filters.status !== "ALL" && order.status !== filters.status) return false;
        return true;
      })
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .map((order) => {
        const truck = state.trucks.find((item) => item.id === order.truckId);
        const maintenanceType = getMaintenanceType(state, order.maintenanceTypeId);

        if (!truck) throw new Error("Camión no encontrado para orden");

        const overdueMiles = Math.max(0, truck.currentOdometer - order.dueAtOdometer);
        const visualState =
          order.status === "COMPLETED" || order.status === "CANCELLED"
            ? order.status
            : overdueMiles > 0
              ? "OVERDUE"
              : "DUE";

        return {
          ...order,
          truck,
          maintenanceType,
          overdueMiles,
          visualState,
          serviceHistory: state.serviceHistory.find((item) => item.workorderId === order.id)
        };
      });

    return rows;
  },

  startWorkOrder(workOrderId: string) {
    return withDbState((state) => {
      const actor = getActorFromState(state);
      const order = state.workOrders.find((item) => item.id === workOrderId);
      if (!order) throw new Error("Orden no encontrada");
      if (order.status === "COMPLETED" || order.status === "CANCELLED") {
        throw new Error("La orden ya está cerrada");
      }

      order.status = "IN_PROGRESS";
      order.assignedToId = order.assignedToId ?? actor.id;
      return order;
    });
  },

  completeWorkOrder(input: {
    workOrderId: string;
    odometerAtService: number;
    notes?: string;
    attachmentUrl?: string;
  }) {
    return withDbState((state) => {
      const actor = getActorFromState(state);
      const order = state.workOrders.find((item) => item.id === input.workOrderId);
      if (!order) throw new Error("Orden no encontrada");

      if (order.status === "COMPLETED" || order.status === "CANCELLED") {
        throw new Error("La orden ya está cerrada");
      }

      const truck = state.trucks.find((item) => item.id === order.truckId);
      if (!truck) throw new Error("Camión no encontrado");

      if (input.odometerAtService > truck.currentOdometer) {
        throw new Error("El odómetro de servicio no puede ser mayor al actual del camión");
      }

      order.status = "COMPLETED";
      order.completedAt = nowIso();
      order.assignedToId = order.assignedToId ?? actor.id;

      const existingHistory = state.serviceHistory.find((item) => item.workorderId === order.id);
      if (!existingHistory) {
        const createdHistory: ServiceHistory = {
          id: newId(),
          truckId: order.truckId,
          maintenanceTypeId: order.maintenanceTypeId,
          workorderId: order.id,
          performedAt: nowIso(),
          odometerAtService: input.odometerAtService,
          performedById: actor.id,
          notes: input.notes,
          attachmentUrl: input.attachmentUrl
        };
        state.serviceHistory.push(createdHistory);
      }

      const maintenanceState = ensureMaintenanceState(state, order.truckId, order.maintenanceTypeId);
      maintenanceState.lastServiceOdometer = input.odometerAtService;
      maintenanceState.lastServiceAt = nowIso();
      maintenanceState.updatedAt = nowIso();

      const maintenanceSnapshot = evaluateTruckMaintenance({
        state,
        truckId: order.truckId,
        currentOdometer: truck.currentOdometer,
        pruneNotDue: true
      });

      return {
        workOrder: order,
        maintenanceSnapshot
      };
    });
  },

  getDashboardSummary() {
    const state = loadDbState();

    let dueNow = 0;
    let dueSoon = 0;
    let overdue = 0;

    for (const truck of state.trucks) {
      const maintenanceStates = mapTruckMaintenanceState(state, truck);
      for (const item of maintenanceStates) {
        const milesSince = truck.currentOdometer - item.lastServiceOdometer;

        if (milesSince > item.maintenanceType.intervalMiles) overdue += 1;
        else if (milesSince === item.maintenanceType.intervalMiles) dueNow += 1;
        else if (item.maintenanceType.intervalMiles - milesSince <= item.maintenanceType.warningBeforeMiles) {
          dueSoon += 1;
        }
      }
    }

    const pendingOrders = state.workOrders
      .filter((item) => item.status === "PENDING" || item.status === "IN_PROGRESS")
      .map((order) => {
        const truck = state.trucks.find((item) => item.id === order.truckId);
        const maintenanceType = getMaintenanceType(state, order.maintenanceTypeId);

        return {
          id: order.id,
          workorderNumber: order.workorderNumber,
          truckNumber: truck?.truckNumber ?? "N/A",
          maintenanceName: maintenanceType.name,
          status: order.status,
          dueAtOdometer: order.dueAtOdometer,
          createdAt: order.createdAt
        };
      })
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

    return {
      totals: {
        dueNow,
        dueSoon,
        overdue,
        pendingOrders: pendingOrders.length
      },
      pendingOrders
    };
  },

  getReportSummary(query: ReportQuery) {
    const state = loadDbState();
    const { start, end, rows } = getServiceRowsByRange(state, query);

    const summaryByTruck = state.trucks
      .filter((truck) => (query.truckId ? truck.id === query.truckId : true))
      .map((truck) => {
        const truckRows = rows.filter((row) => row.truckId === truck.id);
        const engrases = truckRows.filter((row) =>
          getMaintenanceType(state, row.maintenanceTypeId).name.toLowerCase().includes("engrase")
        );
        const aceites = truckRows.filter((row) =>
          getMaintenanceType(state, row.maintenanceTypeId).name.toLowerCase().includes("aceite")
        );

        const nextMaintenance = mapTruckMaintenanceState(state, truck)
          .map((item) => {
            const dueAtOdometer = item.lastServiceOdometer + item.maintenanceType.intervalMiles;
            const remainingMiles = dueAtOdometer - truck.currentOdometer;
            return {
              maintenanceType: item.maintenanceType.name,
              dueAtOdometer,
              remainingMiles,
              state:
                remainingMiles < 0 ? "OVERDUE" : remainingMiles === 0 ? "DUE" : "UPCOMING"
            };
          })
          .sort((a, b) => a.remainingMiles - b.remainingMiles)[0];

        const lastService = [...truckRows].sort(
          (a, b) => new Date(b.performedAt).getTime() - new Date(a.performedAt).getTime()
        )[0];

        return {
          truckId: truck.id,
          truckNumber: truck.truckNumber,
          engrases: {
            count: engrases.length,
            dates: engrases.map((item) => item.performedAt)
          },
          cambiosAceite: {
            count: aceites.length,
            dates: aceites.map((item) => item.performedAt)
          },
          lastService: lastService
            ? {
                date: lastService.performedAt,
                service: getMaintenanceType(state, lastService.maintenanceTypeId).name,
                odometer: lastService.odometerAtService
              }
            : null,
          nextMaintenance: nextMaintenance ?? null
        };
      });

    return {
      range: { start, end },
      totalServices: rows.length,
      summaryByTruck
    };
  },

  getReportDetail(query: ReportQuery) {
    const state = loadDbState();
    const { start, end, rows } = getServiceRowsByRange(state, query);

    return {
      range: { start, end },
      rows: rows.map((row) => {
        const truck = state.trucks.find((item) => item.id === row.truckId);
        const actor = state.users.find((item) => item.id === row.performedById);
        const type = getMaintenanceType(state, row.maintenanceTypeId);
        const order = state.workOrders.find((item) => item.id === row.workorderId);

        return {
          date: row.performedAt,
          truck: truck?.truckNumber ?? "N/A",
          service: type.name,
          odometer: row.odometerAtService,
          user: actor?.name ?? "N/A",
          workorderNumber: order?.workorderNumber ?? "N/A"
        };
      })
    };
  },

  exportDetailCsv(query: ReportQuery) {
    const detail = this.getReportDetail(query);
    const header = ["Fecha", "Camion", "Servicio", "Odometro", "Usuario", "Orden"];

    const body = detail.rows.map((row) =>
      [row.date, row.truck, row.service, row.odometer, row.user, row.workorderNumber]
        .map(asCsvCell)
        .join(",")
    );

    return [header.map(asCsvCell).join(","), ...body].join("\n");
  }
};
